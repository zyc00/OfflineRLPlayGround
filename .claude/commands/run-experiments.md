根据上文讨论的实验方案，批量运行实验并汇总结果。

## Arguments

$ARGUMENTS - (可选) 附加说明。例如:
  - "只跑前两个"
  - "并行跑"
  - "跑完后 log"
  - 留空则按对话上下文自动决定

## Instructions

### Step 1: 从对话中提取实验计划

回顾上方对话，找出用户想要运行的实验。提取：
- 每个实验的 **完整 Python 命令**（`python -m RL.xxx ...`）
- 每个实验的 **简短名称**（用于结果表格的行标签）
- 如果对话中没有明确的命令，根据讨论内容自行构建合理的命令

将提取的实验列表展示给用户确认，格式如：

```
准备运行以下 N 个实验：
1. [名称]: `python -m RL.xxx ...`
2. [名称]: `python -m RL.xxx ...`
...
```

### Step 2: 依次运行实验

对每个实验：

1. 打印当前进度：`▶ Running [X/N]: [名称]`
2. 用 `python -u -m ...` 运行（`-u` 确保实时输出）
3. 从 stdout 中解析结果。标准输出格式为：
   ```
   Iter {i}/{total} | step={step} | SR={sr}% | episodes={ep}
   ```
4. 记录每个实验的：
   - 各迭代的 success rate（SR）
   - Peak SR 及对应迭代
   - Final SR（最后一次 eval）
   - Run directory（从输出或 `runs/` 目录推断）
5. 如果实验报错，记录错误信息并继续下一个

**并行运行**：如果 $ARGUMENTS 包含 "并行" 或 "parallel"，用 Bash 后台任务同时运行所有实验，各自输出重定向到临时文件，然后逐一收集结果。否则**依次运行**。

### Step 3: 汇总结果表格

所有实验完成后，输出汇总表格。根据总迭代数选择合适的列（展示 5-8 个代表性迭代点 + Peak + Final）。

格式示例：

```markdown
## 实验结果汇总

| Experiment | Iter 3 | Iter 5 | Iter 7 | Iter 10 | Peak | Final |
|------------|--------|--------|--------|---------|------|-------|
| 名称1 | 65.2% | 78.3% | 85.1% | 93.2% | 93.2% (i10) | 93.2% |
| 名称2 | 60.1% | 72.4% | 80.3% | 88.5% | 88.5% (i10) | 88.5% |
```

列选择规则：
- **短实验** (≤10 iter): 展示 iter 1, 3, 5, 7, 9, 10 + Peak + Final
- **中实验** (11-30 iter): 展示 iter 5, 10, 15, 20, 25, 30 + Peak + Final
- **长实验** (>30 iter): 展示 iter 5, 10, 15, 20, 25, 35, 50 + Peak + Final
- 如果不同实验迭代数不同，以最长的为准，短的实验在超出范围的列填 `—`

### Step 4: 分析与总结

在表格下方给出简要分析：
- 哪个配置效果最好？
- 关键 takeaway（2-3 点）
- 如果有明显异常（如某个实验崩溃或显著低于预期），指出可能原因

### Step 5: 可选后续操作

- 如果 $ARGUMENTS 包含 "log" 或 "记录"，自动将结果追加到 `experiments/log.md`（遵循 log-experiment 的格式）
- 如果用户对话中提到要保存，也执行保存

## Rules

- 运行前必须展示实验列表，确保用户知道将要运行什么
- 每个命令都加 `-u` 标志确保 unbuffered output
- 如果命令中已有 `--exp_name`，保持不变；如果没有，根据实验名称自动加上
- 超时：单个实验默认 10 分钟超时（600000ms）。如果预期实验更长，提前告知用户
- 如果实验中途失败，记录失败信息并继续运行后续实验，不要中断整个流程
- 保留完整的 stdout 输出供后续分析，但只在汇总表格中展示关键指标
- 语言：跟随对话的主要语言
